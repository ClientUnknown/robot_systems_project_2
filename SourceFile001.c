#pragma config(Sensor, S1,     ultrasonic,     sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     ,               sensorEV3_Touch)
#pragma config(Sensor, S3,     gyro,           sensorEV3_Gyro)
#pragma config(Sensor, S4,     ,               sensorEV3_Color, modeEV3Color_Color)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "include/mindsensors-ev3smux.h"
#include "include/mindsensors-imu.h"

void stopFull();
void wander();
void forward(short speed);
void rampLower();
void rampRaise();
void pushEggIntoNest();
void backward(short speed);
void turnAround();
void turnRight();
void turnLeft();
void pushEggTowardsNest();
void grabEgg();
bool atBlackLine();
bool inBase();
bool isStuck();

TLegoColors BASE_COLOR;
TLegoColors ENEMY_BASE_COLOR;

task main() {
	srand(123);
	BASE_COLOR = getColorName(S4);	// replace S1 with color sensor
	if (BASE_COLOR == colorRed) {
		ENEMY_BASE_COLOR = colorBlue;
	} else {
		ENEMY_BASE_COLOR = colorRed;
	}


	forward(75);

	// repeat until we have 30 seconds left
	repeatUntil(nClockMinutes >= 1.5) {
		// wander until we find an egg
		while (SensorValue(S1) > 5) {
			wander();
			if (isStuck()) {
				break;
			}
			if (getColorName(S4) == ENEMY_BASE_COLOR) {
				turnAround();
				forward(50);
				sleep(1500);
			}
		}
		stopFull();
		sleep(500);
		if (SensorValue(S1) <= 5) {
		// push egg to/into nest then turn around from base and leave base
			grabEgg();
			turnAround();
			pushEggTowardsNest();
			pushEggIntoNest();
			turnAround();
			forward(50);
			sleep(1500);
		}
		//resetMotorEncoder(motorB); // reset the encoder so we can determine if we're in our base or enemy base

	}
	// go back to base, may not be necessary
}

// push egg into nest and face 180 degrees from the base
void pushEggIntoNest() {
	// release the ball then backup to ensure we don't hit it
	rampRaise();
	sleep(500);
	backward(-50);
	sleep(700);
}

// move randomly, looking for an egg
void wander () {
	short speed = 0;

	speed = 25 + random(55);
	forward(speed);
}

void grabEgg() {
	rampLower();
}

void pushEggTowardsNest() {
	short speed = 0;

	while (!inBase()) {
		speed = 25 + random(55);
		forward(speed);
		if (isStuck()) {
			return;
		}
	}
}

void turnRight() {
	setMotorSpeed(motorB, 0);
	setMotorSpeed(motorC, 75);
	sleep(750);
	stopFull();
}

void turnLeft() {
	setMotorSpeed(motorC, 0);
	setMotorSpeed(motorB, 75);
	sleep(750);
	stopFull();
}

void stopFull() {
	setMotorSpeed(motorB, 0);
	setMotorSpeed(motorC, 0);
}

void turnAround() {
	//resetGyro(gyro);

	//repeatUntil(getGyroDegrees(gyro) >= 180 || getGyroDegrees(gyro) <= -180) {
		setMotorSpeed(motorC, -20);
		setMotorSpeed(motorB, 75);
	//}
	sleep(750);
	stopFull();
}

void forward(short speed) {
	setMotorSpeed(motorB, speed);
	setMotorSpeed(motorC, speed);
}

void backward(short speed) {
	setMotorSpeed(motorB, speed);
	setMotorSpeed(motorC, speed);
}

void rampLower() {
	setMotorSpeed(motorA, -20);
	sleep(600);
	setMotorSpeed(motorA, 0);
}

void rampRaise() {
	setMotorSpeed(motorA, 20);
}

bool atBlackLine() {
	return (colorBlack == getColorName(S4));
}

bool inBase() {
	return (BASE_COLOR == getColorName(S4));
}



bool isStuck() {
		// check if the motors are stuck
		if (getTouchValue(S2) == 1) {
			// if we're stuck then stop and try to turn
			stopFull();
			backward(-50);
			sleep(1000);
			turnAround();
		}
		return false;
}
